---
title: "GraphQL Basics"
date: "2023-08-19T21:48:00"
template: "post"
draft: false
slug: "graphql-basics"
category: "Blog"
tags:
  - "Software Development"
  - "Web Development"
  - "API"
description: "Learn about GraphQL queries, mutations, subscriptions, and more."
---

My first experience with GraphQL was a long time ago when I was building a website in [Gatsby](https://www.gatsbyjs.com/docs/graphql/). Without further investigations, I remembered it as a query language and something similar to REST, but _only_ as in that I can use the medium to obtain the data I need in a certain format for my applications. Recently, I worked on some documentations around GraphQL, such as the implementation of rate limiting on GraphQL queries and mutations. I was rejoined with the topic and learned a bit more.

In this blog post, we will explore the key concepts of GraphQL and delve into GraphQL queries, mutations, and subscriptions, which form the core building blocks of GraphQL-based systems.

## What is GraphQL

GraphQL is an open-source query language and runtime for APIs that was [built at Facebook](https://engineering.fb.com/2015/09/14/core-data/graphql-a-data-query-language/):

> ...we needed a data-fetching API powerful enough to describe all of Facebook, yet simple enough to be easy to learn and use by our product developers.

> ...we evaluated our options for delivering News Feed data to our mobile apps, including RESTful server resources and FQL tables (Facebookâ€™s SQL-like API). We were frustrated with the differences between the data we wanted to use in our apps and the server queries they required. We donâ€™t think of data in terms of resource URLs, secondary keys, or join tables; we think about it in terms of a graph of objects and the models we ultimately use in our apps like NSObjects or JSON.

GraphQL was given birth. It provides a declarative syntax for clients to request the precise data they need from a server. Unlike traditional RESTful APIs, where each endpoint corresponds to a fixed set of data, GraphQL allows clients to define the structure of the response they require. This flexibility empowers clients to retrieve multiple resources in a single request, eliminating issues like over-fetching and under-fetching of data.

## GraphQL Query, Mutation, and Subscription

GraphQL queries, mutations, and subscriptions should be defined on the server side before clients can interact with the server.

The server is responsible for implementing the resolver functions that handle the actual execution of the queries, mutations, and subscriptions defined in the schema. The resolvers retrieve the requested data from the appropriate data sources, perform any necessary business logic, and return the results to the client.

GraphQL queries, mutations, and subscriptions are then constructed on the client side and sent to the server to request or modify data.

The following learnings use the [GitHub GraphQL API](https://docs.github.com/en/graphql). To follow along, you can simply use the [GitHub GraphQL explorer](https://docs.github.com/en/graphql/overview/explorer) without any setup, or create a GitHub personal access token with the appropriate scopes for the resources you want to interact with.

### GraphQL Query

GraphQL queries are used to retrieve data from the server, analogous to an HTTP GET request.

For example, you can query for the name and description of the [hello-world repository owned by octocat](https://github.com/octocat/Hello-World):

```graphql
query RepoByOctocat {
  repository(owner:"octocat", name:"hello-world") {
    name
    description
  }
}
```

You get the following response:

```text
{
  "data": {
    "repository": {
      "name": "Hello-World",
      "description": "My first repository on GitHub!"
    }
  }
}
```

### GraphQL Mutation

GraphQL mutations are used for modifying data on the server, analogous to an HTTP POST, PUT, or DELETE request. It enables clients to create, update, or delete data by specifying the required changes in the request.

For example, this sample mutation adds a _hooray_ emoji ðŸŽ‰ to the subject with the said ID, which corresponds to the [issue 349](https://github.com/octocat/Hello-World/issues/349) in the hello-world repository:

```graphql
mutation AddReactionToIssue {
  addReaction(input:{subjectId:"MDU6SXNzdWUyMzEzOTE1NTE=",content:HOORAY}) {
    reaction {
      content
    }
  }
}
```

You get a response similar to the following, confirming the emoji was added:

```text
{
  "data": {
    "addReaction": {
      "reaction": {
        "content": "HOORAY"
      }
    }
  }
}
```

### GraphQL Subscriptions

GraphQL subscriptions introduce real-time capabilities to the GraphQL ecosystem and allows for even-based updates. They are similar to GraphQL queries in that they specify fields of data to be returned, but instead of immediately getting the response, the response is sent automatically by the server when the subscribed event occurs. This is particularly useful for building applications that require live data updates.

Not every GraphQL schema has subscription defined. If you runs a subscription against a schema that does not have subscription configured, you get an error similar to the following:

```text
{
  "errors": [
    {
      ...,
      "extensions": {
        "code": "missingSubscriptionConfiguration"
      },
      ...
      "message": "Schema is not configured for subscriptions"
    }
  ]
}
```

I could not seem to find an example with the Github GraphQL API. See Apollo's [Defining a subscription](https://www.apollographql.com/docs/react/data/subscriptions/#defining-a-subscription) see how to enable a subscription on the server side and how to construct a subscription on the client side.

## Final Words

I purposely choose to not make a section listing reasons why you should or should not use GraphQL over RESTful APIs, simply because there is never a one-size-fits-all solution. Both technologies have their benefits and drawbacks, depending on the use cases and implementations of your applications.

However, you could start your evaluation with the following considerations:

* self-documenting capability
* data retrieval efficiency
* API design and versioning
* query flexibility
* typing system
* readability

I encourage you to explore additional resources. Here are a few I tinkered with:

* [GitHub GraphQL API documentation](https://docs.github.com/en/graphql)
* [Facebook Graph API](https://developers.facebook.com/docs/graph-api/)
* [Free to Use Public GraphQL APIs](https://www.apollographql.com/blog/community/backend/8-free-to-use-graphql-apis-for-your-projects-and-demos/), made available in [Apollo studio](Apollo studio)
* [Why Gatsby Uses GraphQL](https://www.gatsbyjs.com/docs/why-gatsby-uses-graphql/)
* [Apollo supergraph demo](https://github.com/apollographql/supergraph-demo), the federated graphs

Bonne lecture!

<br>
